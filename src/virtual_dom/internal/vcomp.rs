//! This module contains the implementation of a virtual component `VComp`.

use super::vdiff::VDiff;
use super::vnode::VNode;
use crate::callback::Callback;
use crate::html::{Component, ComponentUpdate, HiddenScope, NodeRef, Scope, ScopeHolder};
use crate::virtual_dom::VNode as TypedNode;
use std::any::TypeId;
use std::cell::RefCell;
use std::fmt;
use std::rc::Rc;
use stdweb::unstable::TryInto;
use stdweb::web::{document, Element, INode, Node};

/// The method generates an instance of a component.
type Generator = dyn FnOnce(GeneratorType, HiddenScope) -> Mounted;

/// Components can be generated by mounting or by overwriting an old component.
enum GeneratorType {
    Mount(Element, Node),
    Overwrite(HiddenScope),
}

/// A virtual component.
pub struct VComp {
    type_id: TypeId,
    state: Rc<RefCell<MountState>>,
}

enum MountState {
    Unmounted(Unmounted),
    Mounted(Mounted),
    Mounting,
    Detached,
    Overwritten,
}

struct Unmounted {
    generator: Box<Generator>,
}

struct Mounted {
    node_ref: NodeRef,
    scope: HiddenScope,
    destroyer: Box<dyn FnOnce()>,
}

impl VComp {
    /// This method prepares a generator to make a new instance of the `Component`.
    pub fn new<SELF, PARENT>(
        props: SELF::Properties,
        node_ref: NodeRef,
        scope_holder: ScopeHolder<PARENT>,
    ) -> Self
    where
        SELF: Component,
        PARENT: Component,
    {
        let generator = move |generator_type: GeneratorType, parent: HiddenScope| -> Mounted {
            *scope_holder.borrow_mut() = Some(parent.into());

            match generator_type {
                GeneratorType::Mount(element, ancestor) => {
                    let scope: Scope<SELF> = Scope::new();

                    // TODO Consider to send ComponentUpdate::Create after `mount_in_place` call
                    let mut scope = scope.mount_in_place(
                        element,
                        Some(TypedNode::VRef(VNode::VRef(ancestor))),
                        node_ref.clone(),
                        props,
                    );

                    Mounted {
                        node_ref,
                        scope: scope.clone().into(),
                        destroyer: Box::new(move || scope.destroy()),
                    }
                }
                GeneratorType::Overwrite(hidden_scope) => {
                    let mut scope: Scope<SELF> = hidden_scope.into();
                    scope.update(ComponentUpdate::Properties(props));

                    Mounted {
                        node_ref,
                        scope: scope.clone().into(),
                        destroyer: Box::new(move || scope.destroy()),
                    }
                }
            }
        };

        VComp {
            type_id: TypeId::of::<SELF>(),
            state: Rc::new(RefCell::new(MountState::Unmounted(Unmounted {
                generator: Box::new(generator),
            }))),
        }
    }
}

/// Transforms properties and attaches a parent scope holder to callbacks for sending messages.
pub trait Transformer<PARENT: Component, FROM, TO> {
    /// Transforms one type to another.
    fn transform(scope_holder: ScopeHolder<PARENT>, from: FROM) -> TO;
}

impl<PARENT, T> Transformer<PARENT, T, T> for VComp
where
    PARENT: Component,
{
    fn transform(_: ScopeHolder<PARENT>, from: T) -> T {
        from
    }
}

impl<'a, PARENT, T> Transformer<PARENT, &'a T, T> for VComp
where
    PARENT: Component,
    T: Clone,
{
    fn transform(_: ScopeHolder<PARENT>, from: &'a T) -> T {
        from.clone()
    }
}

impl<'a, PARENT> Transformer<PARENT, &'a str, String> for VComp
where
    PARENT: Component,
{
    fn transform(_: ScopeHolder<PARENT>, from: &'a str) -> String {
        from.to_owned()
    }
}

impl<'a, PARENT, F, IN> Transformer<PARENT, F, Callback<IN>> for VComp
where
    PARENT: Component,
    F: Fn(IN) -> PARENT::Message + 'static,
{
    fn transform(scope: ScopeHolder<PARENT>, from: F) -> Callback<IN> {
        let callback = move |arg| {
            let msg = from(arg);
            if let Some(ref mut sender) = *scope.borrow_mut() {
                sender.send_message(msg);
            } else {
                // panic!("Parent component hasn't activated this callback yet");
                log::error!("Parent component hasn't activated this callback yet");
            }
        };
        callback.into()
    }
}

impl<'a, PARENT, F, IN> Transformer<PARENT, F, Option<Callback<IN>>> for VComp
where
    PARENT: Component,
    F: Fn(IN) -> PARENT::Message + 'static,
{
    fn transform(scope: ScopeHolder<PARENT>, from: F) -> Option<Callback<IN>> {
        let callback = move |arg| {
            let msg = from(arg);
            if let Some(ref mut sender) = *scope.borrow_mut() {
                sender.send_message(msg);
            } else {
                panic!("Parent component hasn't activated this callback yet");
            }
        };
        Some(callback.into())
    }
}

impl Unmounted {
    /// Mount a virtual component using a generator.
    fn mount<T: INode>(
        self,
        parent: &T,
        ancestor: Node, // Any dummy expected
        parent_scope: HiddenScope,
    ) -> Mounted {
        let element: Element = parent
            .as_node()
            .as_ref()
            .to_owned()
            .try_into()
            .expect("element expected to mount VComp");
        (self.generator)(GeneratorType::Mount(element, ancestor), parent_scope)
    }

    /// Overwrite an existing virtual component using a generator.
    fn replace(self, old: Mounted, parent_scope: HiddenScope) -> Mounted {
        (self.generator)(GeneratorType::Overwrite(old.scope.into()), parent_scope)
    }
}

enum Reform {
    Keep(Mounted),
    Before(Option<Node>),
}

impl VDiff for VComp {
    /// Remove VComp from parent.
    fn detach(&mut self, parent: &Element) -> Option<Node> {
        match self.state.replace(MountState::Detached) {
            MountState::Mounted(this) => {
                (this.destroyer)();
                this.node_ref.get().and_then(|node| {
                    let sibling = node.next_sibling();
                    parent
                        .remove_child(&node)
                        .expect("can't remove the component");
                    sibling
                })
            }
            _ => None,
        }
    }

    /// Renders independent component over DOM `Element`.
    /// It compares this with an ancestor `VComp` and overwrites it if it is the same type.
    fn apply<PARENT>(
        &mut self,
        parent: &Element,
        previous_sibling: Option<&Node>,
        ancestor: Option<TypedNode<PARENT>>,
        parent_scope: Scope<PARENT>,
    ) -> Option<Node>
    where
        PARENT: Component,
    {
        match self.state.replace(MountState::Mounting) {
            MountState::Unmounted(this) => {
                let reform = match ancestor {
                    Some(TypedNode::VComp(mut vcomp)) => {
                        if self.type_id == vcomp.type_id {
                            match vcomp.state.replace(MountState::Overwritten) {
                                MountState::Mounted(mounted) => Reform::Keep(mounted),
                                _ => Reform::Before(None),
                            }
                        } else {
                            let node = vcomp.detach(parent);
                            Reform::Before(node)
                        }
                    }
                    Some(mut vnode) => {
                        let node = vnode.detach(parent);
                        Reform::Before(node)
                    }
                    None => Reform::Before(None),
                };

                let mounted = match reform {
                    Reform::Keep(mounted) => {
                        // Send properties update when the component is already rendered.
                        this.replace(mounted, parent_scope.into())
                    }
                    Reform::Before(before) => {
                        // This is a workaround, because component should be mounted
                        // over ancestor element if it exists.
                        // There is created an empty text node to be replaced with mount call.
                        let element = document().create_text_node("");
                        if let Some(sibling) = before {
                            parent
                                .insert_before(&element, &sibling)
                                .expect("can't insert dummy element for a component");
                        } else {
                            let previous_sibling =
                                previous_sibling.and_then(|before| before.next_sibling());
                            if let Some(previous_sibling) = previous_sibling {
                                parent
                                    .insert_before(&element, &previous_sibling)
                                    .expect("can't insert dummy element before previous_sibling");
                            } else {
                                parent.append_child(&element);
                            }
                        }
                        let node = element.as_node().to_owned();
                        this.mount(parent, node, parent_scope.into())
                    }
                };

                let node = mounted.node_ref.get();
                self.state.replace(MountState::Mounted(mounted));
                node
            }
            state => {
                self.state.replace(state);
                None
            }
        }
    }
}

impl PartialEq for VComp {
    fn eq(&self, other: &VComp) -> bool {
        self.type_id == other.type_id
    }
}

impl fmt::Debug for VComp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("VComp")
    }
}
